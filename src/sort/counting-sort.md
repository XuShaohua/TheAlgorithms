# 计数排序 Counting Sort

计数排序不是基于比较值的排序算法.

## 计数排序的步骤

计数排序的实现分几个阶段:

- 首先遍历输入数组, 计算元素的取值范围
- 生成计数数组, 其元素个数基于元素的取值范围确定
- 遍历输入数组, 根据每个元素与最小元素的差值作为索引, 更新计数数组
- 更新计数数组, 使之成为前缀和数组
- 初始化输出数组
- 从最后一个元素开始遍历输入数组, 每个元素都存放 `num`
    - 计算当前元素与最小元素的差值 `delta_index`
    - 从计数数组中取得该元素的索引值 `let num_index = count_arr[delta_index]`
    - 更新输出数组, 将 `num` 放到相应的位置, `arr[num_index - 1] = num`
    - 并更新计数数组, 将里面的索引值减1, `count_arr[delta_index] -= 1`

## 计数排序的实现

下面的算法限制了输入元素是 `i32`:

```rust
{{#include assets/counting_sort.rs:50:92}}
```

下面的代码对计数排序加入了泛型的支持, 注意它的类型 `T` 有很多限制:

```rust
{{#include assets/counting_sort.rs:5:49}}
```

## 计数排序的特点

- 空间复杂度是 `O(n + m)`, `n` 是输入数组的大小, `m` 是计数数组的大小, 也就是元素的数值范围
- 时间复杂度是 `O(n + m)`
- 计数排序是稳定排序, 但不是原地排序 (in-place sorting)
- 如果数组中的元素值所处的范围比较大的话, 计数排序的效率就比较低
- 它需要较多的额外空间来存储中间值
- 计数排序要比归并排序和快速排序等基于比较元素值的排序算法都要快
- 计数排序不惧怕有重复的元素, 但是如果元素的取值范围比较大的话, 其效率就很低