{
  "titleSlug": "count-nodes-that-are-great-enough",
  "acRate": 59.00681596884129,
  "content": null,
  "difficulty": "Hard",
  "freqBar": null,
  "frontendQuestionId": "2792",
  "hasSolution": false,
  "hasVideoSolution": false,
  "hints": [
    "<div class=\"_1l1MA\">For each node, calculate a list of <code>k</code> values representing <code>k</code> smallest values in the subtree of that node.</div>",
    "<div class=\"_1l1MA\">To check if a node is great enough, get the described list in the first hint for its children and merge them. Since the resulting list may contain more than <code>k</code> elements, pick <code>k</code> smallest values and discard the extra ones.</div>",
    "<div class=\"_1l1MA\">Now check if the merged list has exactly <code>k</code> elements, and the current node's value is greater than the greatest element in the list, then that node is great enough.</div>"
  ],
  "isFavor": false,
  "paidOnly": true,
  "similarQuestionList": [],
  "status": null,
  "title": "Count Nodes That Are Great Enough",
  "topicTags": [
    {
      "name": "Divide and Conquer",
      "id": "VG9waWNUYWdOb2RlOjEy",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Tree",
      "id": "VG9waWNUYWdOb2RlOjIw",
      "slug": "tree"
    },
    {
      "name": "Depth-First Search",
      "id": "VG9waWNUYWdOb2RlOjIx",
      "slug": "depth-first-search"
    },
    {
      "name": "Binary Tree",
      "id": "VG9waWNUYWdOb2RlOjYxMDU3",
      "slug": "binary-tree"
    }
  ]
}